

package jensen_csci333_bst;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Random;

/**
 * Testing for binary search tree hw
 * @author Ryan Jensen
 * @version October 18, 2014
 */
public class BinarySearchDriver {
    
    /**
     * Returns the string representation of the in order traversal of the array
     * after being turned into a binary search tree. I used a string instead of
     * printing so it would be easier to test it.
     * @param array the array to turn into a bst and traverse
     * @return the string generated by the in order traversal
     */
    public static String bstSort(int[] array){
        BinarySearchTree tree = new BinarySearchTree();
        for (int val : array){
            tree.insert(val);
        }
        return tree.inOrderTraversal();
    }
    
    /**
     * Testing for binary search tree
     * @param args not used
     */
    public static void main(String[] args) {
        Random gen = new Random();
        //bst sort section
        int size = 20;//size of test case
        int bstSortCases = 5;//num of bstSort invocations
        int lower = -50;//highest number
        int upper = 50;//lowest number
        int failed = 0;//number of failed tests
        
        for (int i = 0; i < bstSortCases; i++){
            int[] list = new int[size];
            for (int ii = 0; ii < size; ii++){
                list[ii] = gen.nextInt(upper - lower + 1) + lower;//[0, upper-lower+1)+lower=[lower, upper]
            }
            String tree = bstSort(list);//get the string representation of the sorted bst
            Arrays.sort(list);
            System.out.println("Control: " + Arrays.toString(list));
            System.out.println("BST:     " + tree);
            if (!Arrays.toString(list).equals(tree)){
                System.out.println("*******BST Sort Failed*******");
                failed++;
            }
            System.out.println();
            
        }
        
        

        //insert,search,deleted testing
        ArrayList<Integer> control = new ArrayList<>();//control
        BinarySearchTree bst = new BinarySearchTree();//binary search tree
        int[] toFind = new int[(size+3)/4];//the array of things we will search for and find
        int[] toNotFind = new int[(size+3)/4];//the array of things we will search for and not find
        int[] toRemove = new int[(size+2)/4];//the array of things we will remove
        for (int i = 0; i < size; i++){
            int val = gen.nextInt(upper - lower + 1) + lower;//[0, upper-lower+1)+lower=[lower, upper]
            //initialize control and bst
            control.add(new Integer(val));
            bst.insert(val);
            if (i%4 == 0){
                //every 4 add it to the to find list
                toFind[i/4] = val;
                toNotFind[i/4] = gen.nextInt(upper) + upper + 1;//[0,upper-1]+upper + 1 = [upper+1, 2*upper] 
            }
            if (i%4 == 1){
                //every multiple of 4 plus one add it the toRemove list
                toRemove[i/4] = val;
            }
        }
        System.out.println("Control Size: " + control.size());
        System.out.println(control);
        System.out.println();
        System.out.println("BST Size: " + bst.getSize());
        System.out.println("Preorder Traversal");
        System.out.println(bst.preOrderTraversal());
        System.out.println("Postorder Traversal");
        System.out.println(bst.postOrderTraversal());
        System.out.println("In order Traversal");
        System.out.println(bst.inOrderTraversal());
        
        System.out.println();
        Collections.sort(control);
        System.out.println("Post Sort");
        System.out.println(control);
        if (control.size() != bst.getSize()){
            System.out.println("*******Sizes are different*******");
            failed++;
        }
        if (!bst.inOrderTraversal().equals(control.toString())){
            System.out.println("********Sorted results are different*****");
            failed++;
        }        
        //remove some
        for (int val : toRemove){
            control.remove(new Integer(val));
            bst.delete(val);
        }
        
        System.out.println();
        System.out.println("Size: " + bst.getSize());

        System.out.println("In order Traversal");
        System.out.println(bst.inOrderTraversal());
        
        System.out.println();
        Collections.sort(control);
        System.out.println("Control Size: " + control.size());
        System.out.println(control);
        if (control.size() != bst.getSize()){
            System.out.println("*******Sizes are different*******");
            failed++;
        }
        if (!bst.inOrderTraversal().equals(control.toString())){
            System.out.println("********Sorted results are different*******");
            failed++;
        }
        System.out.println();
        System.out.println("Searching for values in the list");
        for (int val : toFind){
            System.out.println("Value: " + val);
            if (bst.search(val) == null){
                System.out.println("******Didn't find " + val + "********");
                failed++;
            }
        }
        System.out.println();
        System.out.println("Searching for values not in the list");
        for (int val : toNotFind){
            System.out.println("Value: " + val);
            if (bst.search(val) != null){
                System.out.println("******Did find " + val + "********");
                failed++;
            }
        }
        
        System.out.println();
        System.out.println();
        System.out.println();
        System.out.println("Test Summary, Failed: " + failed);
    }
    
}
